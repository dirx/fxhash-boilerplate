<!DOCTYPE html>
<html>
  <head>
    <title>FXHASH project</title>
    <meta charset="utf-8" />
    <script id="fxhash-snippet">
      //---- do not edit the following code (you can indent as you wish)
      let search = new URLSearchParams(window.location.search)
      let alphabet =
        "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
      let b58dec = (str) =>
        [...str].reduce(
          (p, c) => (p * alphabet.length + alphabet.indexOf(c)) | 0,
          0
        )
      // make fxrand from hash
      var fxhash =
        search.get("fxhash") ||
        "oo" +
          Array(49)
            .fill(0)
            .map((_) => alphabet[(Math.random() * alphabet.length) | 0])
            .join("")
      let fxhashTrunc = fxhash.slice(2)
      let regex = new RegExp(".{" + ((fxhash.length / 4) | 0) + "}", "g")
      let hashes = fxhashTrunc.match(regex).map((h) => b58dec(h))
      let sfc32 = (a, b, c, d) => {
        return () => {
          a |= 0
          b |= 0
          c |= 0
          d |= 0
          var t = (((a + b) | 0) + d) | 0
          d = (d + 1) | 0
          a = b ^ (b >>> 9)
          b = (c + (c << 3)) | 0
          c = (c << 21) | (c >>> 11)
          c = (c + t) | 0
          return (t >>> 0) / 4294967296
        }
      }
      var fxrand = sfc32(...hashes)
      // make fxrandminter from minter address
      var fxminter =
        search.get("fxminter") ||
        "tz1" +
          Array(33)
            .fill(0)
            .map((_) => alphabet[(Math.random() * alphabet.length) | 0])
            .join("")
      let fxminterTrunc = fxminter.slice(3)
      regex = new RegExp(".{" + ((fxminterTrunc.length / 4) | 0) + "}", "g")
      hashes = fxminterTrunc.match(regex).map((h) => b58dec(h))
      var fxrandminter = sfc32(...hashes)

      // true if preview mode active, false otherwise
      // you can append preview=1 to the URL to simulate preview active
      var isFxpreview = search.get("preview") === "1"
      // call this method to trigger the preview
      function fxpreview() {
        console.log("FXPREVIEW")
        // window.dispatchEvent(new Event("fxhash-preview"))
        // setTimeout(() => fxpreview(), 500)
      }

      // get the byte params from the URL
      const searchParams = search.get("fxparams")
      let initialInputBytes = searchParams?.replace("0x", "")
      const debounce = (func, delay) => {
        let t
        let isFirstCall = true
        return function (...args) {
          const c = this
          if (isFirstCall) {
            func.apply(c, args)
            isFirstCall = false
          } else {
            clearTimeout(t)
            t = setTimeout(() => {
              func.apply(c, args)
            }, delay)
          }
        }
      }

      const _updateUrl = debounce((url) => {
        window.history.pushState({ path: url.href }, "", url.href)
      }, 300)

      const stringToHex = function (s) {
        let rtn = ""
        for (let i = 0; i < s.length; i++) {
          rtn += s.charCodeAt(i).toString(16).padStart(4, "0")
        }
        return rtn
      }

      function completeHexColor(hexCode) {
        let hex = hexCode.replace("#", "")
        if (hex.length === 6) {
          hex = `${hex}ff`
        }
        if (hex.length === 3) {
          hex = `${hex[0]}${hex[0]}${hex[1]}${hex[1]}${hex[2]}${hex[2]}ff`
        }
        return hex
      }

      // the parameter processor, used to parse fxparams
      const processors = {
        number: {
          serialize: (input) => {
            const view = new DataView(new ArrayBuffer(8))
            view.setFloat64(0, input)
            return view.getBigUint64(0).toString(16).padStart(16, "0")
          },
          deserialize: (input) => {
            const view = new DataView(new ArrayBuffer(8))
            for (let i = 0; i < 8; i++) {
              view.setUint8(i, parseInt(input.substring(i * 2, i * 2 + 2), 16))
            }
            return view.getFloat64(0)
          },
          bytesLength: () => 8,
          constrain: (value, definition) => {
            let min = Number.MIN_SAFE_INTEGER
            if (typeof definition.options?.min !== "undefined")
              min = Number(definition.options.min)
            let max = Number.MAX_SAFE_INTEGER
            if (typeof definition.options?.max !== "undefined")
              max = Number(definition.options.max)
            max = Math.min(max, Number.MAX_SAFE_INTEGER)
            min = Math.max(min, Number.MIN_SAFE_INTEGER)
            const v = Math.min(Math.max(value, min), max)
            if (definition?.options?.step) {
              const t = 1.0 / definition?.options?.step
              return Math.round(v * t) / t
            }
            return v
          },
          random: (definition) => {
            let min = Number.MIN_SAFE_INTEGER
            if (typeof definition.options?.min !== "undefined")
              min = Number(definition.options.min)
            let max = Number.MAX_SAFE_INTEGER
            if (typeof definition.options?.max !== "undefined")
              max = Number(definition.options.max)
            max = Math.min(max, Number.MAX_SAFE_INTEGER)
            min = Math.max(min, Number.MIN_SAFE_INTEGER)
            const v = Math.random() * (max - min) + min
            if (definition?.options?.step) {
              const t = 1.0 / definition?.options?.step
              return Math.round(v * t) / t
            }
            return v
          },
        },
        bigint: {
          serialize: (input) => {
            const view = new DataView(new ArrayBuffer(8))
            view.setBigInt64(0, BigInt(input))
            return view.getBigUint64(0).toString(16).padStart(16, "0")
          },
          deserialize: (input) => {
            const view = new DataView(new ArrayBuffer(8))
            for (let i = 0; i < 8; i++) {
              view.setUint8(i, parseInt(input.substring(i * 2, i * 2 + 2), 16))
            }
            return view.getBigInt64(0)
          },
          bytesLength: () => 8,
          random: (definition) => {
            const MIN_SAFE_INT64 = -9223372036854775808n
            const MAX_SAFE_INT64 = 9223372036854775807n
            let min = MIN_SAFE_INT64
            let max = MAX_SAFE_INT64
            if (typeof definition.options?.min !== "undefined")
              min = BigInt(definition.options.min)
            if (typeof definition.options?.max !== "undefined")
              max = BigInt(definition.options.max)
            const range = max - min
            const bits = range.toString(2).length
            let random
            do {
              random = BigInt(
                "0b" +
                  Array.from(
                    crypto.getRandomValues(new Uint8Array(Math.ceil(bits / 8)))
                  )
                    .map((b) => b.toString(2).padStart(8, "0"))
                    .join("")
              )
            } while (random > range)
            return random + min
          },
        },
        boolean: {
          serialize: (input) => {
            return typeof input === "boolean"
              ? input
                ? "01"
                : "00"
              : typeof input === "string"
              ? input === "true"
                ? "01"
                : "00"
              : "00"
          },
          // if value is "00" -> 0 -> false, otherwise we consider it's 1
          deserialize: (input) => {
            return input === "00" ? false : true
          },
          bytesLength: () => 1,
          random: () => Math.random() < 0.5,
        },
        color: {
          serialize: (input) => {
            return completeHexColor(input)
          },
          deserialize: (input) => input,
          bytesLength: () => 4,
          transform: (input) => {
            const r = parseInt(input.slice(0, 2), 16)
            const g = parseInt(input.slice(2, 4), 16)
            const b = parseInt(input.slice(4, 6), 16)
            const a = parseInt(input.slice(6, 8), 16)
            return {
              hex: {
                rgb: "#" + input.slice(0, 6),
                rgba: "#" + input,
              },
              obj: {
                rgb: { r, g, b },
                rgba: { r, g, b, a },
              },
              arr: {
                rgb: [r, g, b],
                rgba: [r, g, b, a],
              },
            }
          },
          constrain: (value, definition) => {
            const hex = value.replace("#", "")
            return hex.slice(0, 8).padEnd(8, "f")
          },
          random: () =>
            `${[...Array(8)]
              .map(() => Math.floor(Math.random() * 16).toString(16))
              .join("")}`,
        },
        string: {
          serialize: (input, def) => {
            let max = 64
            if (typeof def.options?.maxLength !== "undefined")
              max = Number(def.options.maxLength)
            let hex = stringToHex(input.substring(0, max))
            hex = hex.padEnd(max * 4, "0")
            return hex
          },
          deserialize: (input) => {
            const hx = input.match(/.{1,4}/g) || []
            let rtn = ""
            for (let i = 0; i < hx.length; i++) {
              const int = parseInt(hx[i], 16)
              if (int === 0) break
              rtn += String.fromCharCode(int)
            }
            return rtn
          },
          bytesLength: (options) => {
            if (typeof options?.maxLength !== "undefined")
              return Number(options.maxLength) * 2
            return 64 * 2
          },
          constrain: (value, definition) => {
            let min = 0
            if (typeof definition.options?.minLength !== "undefined")
              min = definition.options.minLength
            let max = 64
            if (typeof definition.options?.maxLength !== "undefined")
              max = definition.options.maxLength
            let v = value.slice(0, max)
            if (v.length < min) {
              return v.padEnd(min)
            }
            return v
          },
          random: (definition) => {
            let min = 0
            if (typeof definition.options?.minLength !== "undefined")
              min = definition.options.minLength
            let max = 64
            if (typeof definition.options?.maxLength !== "undefined")
              max = definition.options.maxLength
            const length = Math.round(Math.random() * (max - min) + min)
            return [...Array(length)]
              .map((i) => (~~(Math.random() * 36)).toString(36))
              .join("")
          },
        },
        select: {
          serialize: (input, def) => {
            // find the index of the input in the array of options
            return Math.min(255, def.options?.options?.indexOf(input) || 0)
              .toString(16)
              .padStart(2, "0")
          },
          deserialize: (input, definition) => {
            return (
              definition.options.options[parseInt(input, 16)] ||
              definition.default
            )
          },
          bytesLength: () => 1,
          constrain: (value, definition) => {
            if (definition.options.options.includes(value)) {
              return value
            }
            return definition.options.options[0]
          },
          random: (definition) => {
            const index = Math.round(
              Math.random() * (definition?.options?.options?.length - 1) + 0
            )
            return definition?.options?.options[index]
          },
        },
      }

      // params are injected into the piece using the binary representation of the
      // numbers, to keep precision
      function serializeParams(params, definition) {
        // a single hex string will be used for all the params
        let bytes = ""
        if (!definition) return bytes
        // loop through each parameter from the definition to find the associated
        // parameter as set on the UI
        for (const def of definition) {
          const { id, type } = def
          const processor = processors[type]
          // if the param is definined in the object

          const v = params[id]
          const val =
            typeof v !== "undefined"
              ? v
              : typeof def.default !== "undefined"
              ? def.default
              : processor.random(def)
          const serialized = processor.serialize(val, def)
          bytes += serialized
        }

        return bytes
      }

      // takes the parameters as bytes and outputs an object with the
      // deserialized parameters, identified by their id in an object
      const deserializeParams = (bytes, definition) => {
        const params = {}
        for (const def of definition) {
          const processor = processors[def.type]
          // if we don't have any parameters defined in the URL, set the
          // default value and move on
          if (!bytes) {
            let v
            if (typeof def.default === "undefined") v = processor.random(def)
            else v = def.default
            params[def.id] = processor.constrain?.(v, def) || v
            continue
          }
          // extract the length from the bytes & shift the initial bytes string
          const valueBytes = bytes.substring(
            0,
            processor.bytesLength(def?.options) * 2
          )
          bytes = bytes.substring(processor.bytesLength(def?.options) * 2)
          // deserialize the bytes into the params
          const value = processor.deserialize(valueBytes, def)
          params[def.id] = processor.constrain?.(value, def) || value
        }
        return params
      }

      const processParam = (paramId, value, definitions, transformer) => {
        const definition = definitions.find((d) => d.id === paramId)
        const processor = processors[definition.type]
        return processor[transformer]?.(value, definition) || value
      }

      const processParams = (values, definitions, transformer) => {
        const paramValues = {}
        for (const definition of definitions) {
          const processor = processors[definition.type]
          const value = values[definition.id]
          // deserialize the bytes into the params
          paramValues[definition.id] =
            processor[transformer]?.(value, definition) || value
        }
        return paramValues
      }

      window.$fx = {
        _version: "3.0.0",
        _processors: processors,
        _settings: {},
        // where params def & features will be stored
        _params: undefined,
        _features: undefined,
        // where the parameter values are stored
        _paramValues: {},
        _listeners: {},
        on: function (name, callback, onDone) {
          if (!this._listeners[name]) {
            this._listeners[name] = []
          }
          this._listeners[name].push([callback, onDone])
          return function removeListener() {
            const index = this._listeners[eventName].findIndex(
              ([c]) => c === callback
            )
            if (index > -1) {
              this._listeners[eventName].splice(index, 1)
            }
          }
        },
        call: async function (name, data) {
          const results = []
          if (this._listeners && this._listeners[name]) {
            for (const [callback, onDone] of this._listeners[name]) {
              const result = callback(data)
              if (result instanceof Promise) {
                results.push([await result, onDone])
              } else {
                results.push([result, onDone])
              }
            }
          }
          return results
        },
        hash: fxhash,
        rand: fxrand,

        minter: fxminter,
        randminter: fxrandminter,

        inputBytes: initialInputBytes,

        preview: fxpreview,
        isPreview: isFxpreview,
        params: function (definition) {
          // todo: maybe do some validation on the dev side ?
          // or maybe not ?
          this._params = definition
          this._rawValues = deserializeParams(initialInputBytes, definition)
          this._paramValues = processParams(
            this._rawValues,
            definition,
            "transform"
          )
          this._updateInputBytes()
        },
        _updateParam: function (id, value) {
          const definition = this._params.find((d) => d.id === id)
          const processor = processors[definition.type]
          const v = processor.constrain?.(value, definition) || value
          this._rawValues[id] = v
          this._paramValues[id] = processor.transform?.(v) || v
          this._updateInputBytes()
        },
        _updateParams: function (newValues) {
          const constrained = processParams(
            { ...this._rawValues, ...newValues },
            this._params,
            "constrain"
          )
          Object.keys(constrained).forEach((paramId) => {
            this._rawValues[paramId] = constrained[paramId]
          })
          this._paramValues = processParams(
            this._rawValues,
            this._params,
            "transform"
          )
          this._updateInputBytes()
        },
        _receiveParamsUpdate: async function ({ bytes, id, value }) {
          const handlers = await this.call("paramsUpdate", { bytes, value, id })
          handlers.forEach(([handled, onDone]) => {
            if (!handled) {
              this._updateParam(id, value)
            }
            onDone?.()
          })
          if (handlers.length === 0) this._updateParam(id, value)
        },
        _updateInputBytes: function () {
          const bytes = serializeParams(this._rawValues, this._params)
          this.inputBytes = bytes
          const url = new URL(window.location.href)
          url.searchParams.set("fxparams", `0x${bytes}`)
          _updateUrl(url)
        },
        features: function (features) {
          this._features = features
        },
        getFeature: function (id) {
          return this._features[id]
        },
        getFeatures: function () {
          return this._features
        },
        getParam: function (id) {
          return this._paramValues[id]
        },
        getParams: function () {
          return this._paramValues
        },
        getRawParam: function (id) {
          return this._rawValues[id]
        },
        getRawParams: function () {
          return this._rawValues
        },
        getDefinitions: function () {
          return this._params
        },
        stringifyParams: function (params) {
          return JSON.stringify(
            params,
            (key, value) => {
              if (typeof value === "bigint") return value.toString()
              return value
            },
            2
          )
        },
        syncParams: function (rawValues) {
          this._updateParams(rawValues)
          const constrained = Object.keys(rawValues).reduce((acc, paramId) => {
            acc[paramId] = processParam(
              paramId,
              rawValues[paramId],
              this._params,
              "constrain"
            )
            return acc
          }, {})
          parent.postMessage(
            {
              id: "fxhash_syncParams",
              data: {
                params: constrained,
              },
            },
            "*"
          )
        },
      }

      window.addEventListener("message", async (event) => {
        if (event.data === "fxhash_getInfo") {
          parent.postMessage(
            {
              id: "fxhash_getInfo",
              data: {
                version: window.$fx._version,
                hash: window.$fx.hash,
                features: window.$fx.getFeatures(),
                params: {
                  definitions: window.$fx.getDefinitions(),
                  values: window.$fx.getRawParams(),
                },
                minter: window.$fx.minter,
                settings: window.$fx._settings,
              },
            },
            "*"
          )
        }
        if (event.data?.id === "fxhash_updateParams") {
          const { bytes, value, id } = event.data.data
          if (id) window.$fx._receiveParamsUpdate({ bytes, value, id })
        }
      })
      // END NEW

      //---- /do not edit the following code
    </script>

    <link rel="stylesheet" href="./style.css" />

    <!-- if you need to import js scripts do it here -->
  </head>
  <body>
    <!-- WEBPACK will inject the bundle.js here -->
  </body>
</html>
